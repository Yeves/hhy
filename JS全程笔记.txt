Day01am------>
正课：
1. 什么是js
2. 如何编写，如何运行，如何调试js程序
3. ***变量
4. ***数据类型

1. 什么是js：
前端三大语言：HTML：专门编写网页内容的语言
              CSS：专门美化网页样式的语言
*************************************************
交互：输入数据，处理数据，返回结果
JavaScript：专门编写网页交互的语言
程序：让计算机可以执行任务的指令的序列

Netscape：网景
客户端脚本语言：LiveScript
Sun Java――“write once run anywhere”
LiveScript: JavaScript
            "像极了Java，但比Java简单的多"

JavaScript-->ECMA-->ECMAScript:行业标准，规定核心语法！
Netscape：遵照标准实现JavaScript
Microsoft：遵照标准实现JScript

W3C：DOM标准：专门操作网页内容的API标准

JavaScript：ECMAScript(核心语法)+DOM(专门操作网页内容)
            BOM(专门操作浏览器窗口)

2004：Mozilla Firefox

2. 如何使用：
   运行方式：2种：
   1. 使用浏览器自带的js引擎：
浏览器中包含两个引擎：
	内容排版引擎：负责加载HTML内容，渲染css样式
        js解释器/引擎：负责解释，并执行js程序
浏览器控制台：专门调试程序，显示输出结果的浏览器窗口
第一行脚本：console.log("Hello World");
    console指控制台
    .翻译为"的"
    log是控制台提供的一个现有功能，用来记录一行话
    强调：2点：
1. js中凡是要输出的正文都要用引号包裹，但单双引号不分
2. js区分大小写！js规定小写的名称，就必须小写！

    document.write("...");
  //使用网页的写入方法，向网页内容中写入HTML内容
    window.alert("...");
//使用窗口的警告功能，弹出警告框，显示自定义警告内容。

    控制台编写多行语句：Shift+Enter

    2. 独立安装的js引擎：node.js   V8
       让js运行在任何平台。

网页中如何编写js：3种方式：
1. 网页中的<script>元素中：
   <script>专门保存js程序的元素
   <script>可以写在网页的任何位置，随网页解释执行
   脚本：不用编译，直接边解释边执行的程序

2. 元素的事件属性中：
   事件：用户或浏览器自身触发的动作
   事件触发后，才会执行事件处理程序
   <元素 on事件名="事件处理程序（js语句）"...
   <p onclick="window.alert('Hello onclick')"...
      当单击的时候，请window窗口，弹出警告

3. 单独的.js文件中集中编写：
   执行过程和在<script>中编写的脚本完全一样！
   2步：
   1. 新建.js文件，包含js程序
   2. 在页面顶端，引入外部js文件：
	<script src="路径"></script>

如何调试js程序：
    1. js中错误：只要希望的功能没执行，说明功能出错了
                 ***只要出错先开F12（控制台）***
       控制台中包含：错误类型：错误原因     错误位置链接
       错误现象：出错位置之前的代码――正常执行
              同一script中出错位置之后的代码――不执行
              一个script出错，不影响其他位置script的执行
程序错误：bug    处理解决错误：debug

Day01pm------>
正课：
1. ***变量
2. ***数据类型

1. 变量：
   什么是变量：内存中一块存储一个数据的空间
               再起一个名字。
 何时使用变量：程序中的一切数据都要保存在变量中，反复使用
   如何使用变量：2种情况
    1. 赋值：2步：
        1. 创建变量：――声明――创建一个新的空变量
           语法：var 变量名;
           强调：仅声明，未赋值的变量，默认值是undefined
       变量命名：见名知义
          1. *不能以数字开头
          2. *不能用保留字：被js已经占用，有特殊意义的词
          3. 如果又多个单词组成，一般采用驼峰命名：
              第一个单词首字母小写，其余单词首字母大写

        2. 赋值：将数据保存到变量中
           语法：变量名=数据;
           其中：=就是赋值的意思。
           将等号右边的"数据"，放到等号左边的变量中保存
	强烈建议：在声明同时就赋值
           语法：var 变量名=数据;
           强调：程序中的赋值，都是*替换*变量中原有旧值
    2. 取值：使用变量名，等效于直接使用变量中保存的数据

特殊情况：
1. *给未声明过的变量赋值不会出错，程序会在window范围内自动创建同名变量，再赋值。*：
   强烈建议，所有变量用var声明
   如果不带var，js会自动在之前加：window.
   变量的本质：都是window环境下的存储空间
      var a ==> window.a ==> a
2. *从未声明过的变量中取值一定会出错*：ReferenceError

3. 变量之间赋值：形如：变量1=变量2;
     执行时：将变量2中的数据复制一个副本放入变量1中。 
             变量2中原数据保持不变。
     此后，变量1和变量2之间，不再有任何联系！

4. ***声明提前：在正式执行js脚本之前，js引擎会提前阅读程序中的所有var。将所有变量集中到程序开始位置声明！
   ***赋值，仍留在原地！***
   比如：console.log(m); //不会出错！输出undefined
         var m=100; 
         console.log(m); //输出100
   建议：在程序开始位置集中声明变量

常量：一旦创建，值不可改变的量
何时使用常量？一旦创建，值不希望被篡改时，就要保存为常量
语法: const 常量名=值;
如何使用常量？用法和变量完全一样！除了不能赋值！

2. ***数据类型：数据在内存中的存储格式
   为什么要有不同数据类型：
	不同数据的类型，可执行的操作不同
   js中数据类型：2大类：
     1. 原始类型：数据直接保存在变量本地的数据类型！
	5种：String，Number，Boolean，undefined，null

     2. 引用类型：数据不保存在变量本地的数据类型！(待续)

   1. Number类型：js中专门保存数字的类型，不带引号！
      何时使用：用于计算或比较大小时，都用Number类型
      其实数字分两种情况：整数，浮点数(小数)
          整数：4字节(byte) 32位
          浮点数：8字节(byte) 64位
      8Bit=1byte  1KB=1024byte  1MB=1024KB ...
      8位=1字节
          Number类型所占空间和数值大小没有直接关系。
          比如：var n=1; n占4字节
                var m=100000000; m也占4字节
***舍入误差：因为计算机无法精确表示1/10，造成的计算误差
            不可避免！
       近似解决：n.toFixed(2)：将n按2位小数四舍五入！

   2. String类型：专门保存一串文字的数据类型
            强调：字符串必须用引号包裹！
      何时使用：用于输出或显示的文字都要加双引号
          1. 所占空间：js采用Unicode字符集编码
               unicode：对全球主要文字的每个字符编一个号
               js中每个字母，数字，英文标点占1字节
	       js中每个汉字占2字节！
          比如：“Hello马里奥”
             1*5+2*3=11个字节
          2. *字符串内容一旦创建不可改变*！
             两个字符串可使用+拼接为1个字符串
          比如：var str1="Hello";
	        str1=str1+"World";
	        console.log(str1); //共创建3个字符串

   3. Boolean: 专门定义真假的类型：true false
       何时使用boolean？如果数据只有两种情况时，可用boolean类型
     比如：var isRain=false
           var isMan=true
           var isClassOver=true



Day02am------>
JavaScript权威指南（犀牛书）
微信公众号：前端大全

回顾：
1. 变量：声明(var) 赋值(=) 
         取值(使用变量名等效于直接使用变量中的数据)
   ***变量声明提前：仅var被预读到开始位置，赋值留在原地
    比如：console.log(m);//?undefined
          var 
m=100;

          console.log(m);//?100
   ***使用变量报错：从未声明的变量中取值：ReferenceError
      var n; console.log(n); 
             console.log(m); //报错：m is not defined
   ***省略var：程序会自动加window.前缀
2. 数据类型：2大类
      1. 原始类型：数据直接保存在变量本地
         5种：Number(舍入误差) 
              String(每个字母/数字/标点 1字节
                     每个汉字 2字节
		     ***内容一旦创建不可改变)
              var str1="Hello";
              str1=str1+"world";
              //创建过3个
              Boolean（true false）
      2. 引用类型：数据不保存在变量本地

正课：
1. ***数据类型转换
2. ***运算符和表达式

1. 数据类型转换：***js是弱类型编程语言
               1. 声明变量时，不必提前规定变量的数据类型
               2. 赋值时，根据存入数据，动态决定数据类型
             3. 运算时，js会根据需要，动态转换数据的类型
  2大类：
  1. 隐式转换：不需要程序员干预，js会根据需要自动转换类型
	仅讨论+运算中的隐式转换*规律*：
            没有字符串参与：所有类型都转为Number类型
                            做算术计算！
                	Boolean：true->1  false->0
            有字符串参与：所有类型都转为String类型
                            做字符串拼接
            多个数据+运算：从左向右，两两计算
	    注意：隐式转换发生在运算过程中，
                  不改变变量中的实际存储。
  2. 强制转换：程序员通过调用专门函数，明确的转换数据类型
     1. 任意类型-->String: 2种：
        var str=x.toString(); 
        var str=String(x); //相当于隐式转换
        补：typeof(x): 返回x的数据类型名称
        何时使用：不需要自己调用，程序根据需要会自动调用
     2. ***任意类型-->Number：2种
      var n=Number(x); 将*任意类型*数据，转为Number类型
                     //相当于隐式转换
var n=parseInt(str); 专用于将*String*类型转为Number类型
        本质：从左向右依次读取str中的整数部分！
              返回值：整数
              碰到第一个不是数字的字符，停止读取!
        特点：1. 不认识小数点！
              2. 跳过空格！
        比如：var str="12px"  "$12"  "   12.56  "
                       12      NaN       12
              var n=parseInt(str); 12
***如果无法转为数字，则返回NaN
   什么是NaN：Not a Number：不是数字的数字

      parseFloat(str); 用法和parseInt完全相同！
                 差别：parseFloat认识*第一个*小数点
                       返回值：浮点数
       比如：var str="12.5px" "12.0px" "12.5.5"
                      12.5     12       12.5
             var f=parseFloat(str); //12.5
     总结：将非字符串类型转数字：Number(x)
           将字符串转数字：parseInt(str)

     3. 任意类型-->Boolean: 
		var bool=Boolean(x);//相当于隐式转换
  
     课堂练习：
	输入框：var input=[window.]prompt("输入提示");
        ***凡是从页面上获得的任何数据，都是字符串类型



2. ***运算符：程序中模拟人思维运算的特殊符号
     什么是表达式：由运算符，变量，数据组成的一条语句；
　
　　８种：
　　１.算术运算：+ - * / % ++ --
       算术运算中，一切数据默认都转为Number计算
       算术运算的结果，只可能是数字 
       强调：如无法转为数字，则转为NaN
             NaN和任何数据做计算，结果还是NaN。

       %模运算（取余数）:被除数/除数，取除不尽的余数部分
          6789%100=89; 6789/100, 取除不尽的余数部分
          17%3=2; 
       何时使用：1. 判断能否整除，判断奇数偶数：
             n%2等于0  偶数   n%2等于1  奇数
           2. 余数不可能>被除数，通常用模运算限制一个运算的结果不能超过某数

Day02pm------>
正课：
1. ++ --
2. 关系运算：专门做比较和判断的运算符
3. 位运算：
4. 赋值运算：
5. 三目运算

1. ++ --:
   ++: 前++：将变量本身的值+1，返回*新值*
   比如：var n=10;//旧值 console.log(++n); //返回新值11
       后++：将变量本身的值+1，返回*旧值*
   比如：var n=10;//旧值 console.log(n++); //返回旧值10
   --：用法和++完全一样：n-- ==> n=n-1

   总结：单用：两者无差别！
         ++用于其他表达式中时：前++返回新值，
                               后++返回旧值

2. 关系运算：做比较，做判断。所有关系运算都返回Boolean值
     > < >= <= == !=
   关系运算中，所有数据默认转为数字类型比较
   	如果无法转为数字，则转为NaN，
   	但NaN和任意数据做比较，永远不相等！
   特殊情况：两字符串做比较：
       依次PK两字符串中每个字符的unicode码
       只要任意一位字符比较出结果就不再继续向后比较
        var name1="Eric"; var name2="Scott";
	"E" 69 < "S" 83
	name1>name2 false
        var name3="Smith";
        "S" 83 = "S" 83
        "c" 99 < "m" 109
	"Scott" < "Smith"
        name2>name3 false

   NaN：和任何元素做> < ==比较都返回false
        和任何元素做!=比较都返回true
   问题：无法用==或!=判断一个数据是否是NaN
   解决：isNaN(x): 专门用于判断任意数据是否是NaN
       *专门用于判断任意数据是否是数字或可被隐式转为数字
            如果x是数字或可以被隐式转为数字，则返回false
          如果x不是数字或不可被隐式转为数字，则返回true

   undefined vs null: 程序中二者本应完全相同，但用途不同
       undefined自动初始化变量
       null主动清空变量
   问题：undefined==null ==> true
      自动转为null
   解决：===: 严格相等/全等：不带隐式转换！
              要求参与比较的数据，类型必须相等
   undefined===null ==>false
   undefined   Object
    何时使用：今后只要判断null或undefined，都要用===
         只要不希望比较时自动类型转换，就用===

3. 逻辑运算：利用多组关系运算，综合判断得出结论
            返回值还是Boolean值
   3种：&&: "而且" 所有条件都为true，结果才能为true
	    只要有一个条件为false，结果只能为false
        ||: "或" 只要有一个条件为true，结果就能为true
            所有条件都为false，结果才为false
        !: 颠倒一切Boolean结果
   ***短路逻辑：前一个条件已经能够得出结果
		后续条件不再执行！
   
/*查看day02素材-->operators.jpg：js运算符优先级
  优先级高的，先运算！圆括号可改变优先级顺序*/

4. 位运算：
    左移：n<<m   n* 2的m次方
    右移：n>>m   n/ 2的m次方
    比如：3<<4  3*(2*2*2*2)=48
          64>>3  64/(2*2*2)=8

5. 赋值运算：= 将等号右边的值保存到等号左边的变量中
     扩展赋值运算：+= -= *= /= %=
       n=n+1; n++; 问题：仅能递增1
       n=n+2; n+=2; 累加2; 或递增2 直接修改原变量中的值
              n+=3; 累加3; 或得增3
     何时使用：只要做累加时，都要用扩展赋值运算。
     
     -=,*=,/=,%=用法同+=
      n-=2; ==>n=n-2;
      n*=2; ==>n=n*2;
      n/=2; ==>n=n/2;
      n%=2; ==>n=n%2;

6. 三目运算：根据不同的条件，多选一，返回不同的结果
     何时使用：只要根据不同条件返回不同结果时
   语法：条件?满足条件返回的值:
            不满足条件返回的值
   强调：返回值：只能返回两个值之一！
   
   ***根据多个条件，多选一！
   语法：条件1?满足条件1返回的值:
         条件2?满足条件2返回的值:
         ...
                          默认值;

   体重健康指数（克莱托指数）计算公式如下：		   可莱托指数=体重(kg)÷身高2(m)
   20-25正常，
   20以下瘦，
   25以上胖。   例如：某人是60kg，1.7m，那就是：60÷1.72=20.76，属于“正常”体重；编写一个函数，接收体重和身高作参数，返回判定结果。

   请用户输入体重和身高
   根据体重和身高计算可莱托指数
   根据可莱托指数的范围输出胖瘦情况
       如果指数>25，输出胖
       如果指数<20, 输出瘦
                否则输出正常
     

Day03am------>
正课：
1. ***函数
2. 全局函数――了解
3. *分支结构

1. 函数：封装一项专门任务步骤清单的代码段
         起一个任务名
   为什么使用函数：重用！
   何时使用：只要发现一项任务，反复编写时，都要封装为函数
   如何定义函数：
	1. 声明：
	   function 任务名([参数变量列表]){
		任务的步骤清单;
                [返回结果;]
           }
        2. 调用：任务名([参数值列表]);

   参数：专门接收传入函数内部的数据的*变量*
   何时使用参数：当函数必须接收某些数据才能正常执行时
   如何声明参数变量：声明函数时，在函数名后的圆括号中
                    不用var
                    每个参数变量之间用逗号分隔
   参数变量的用法：和普通变量完全一样！
   何时/如何传入参数值：调用时，在函数名后的圆括号中
            参数值得个数和顺序要和参数变量声明时保持一致
   总结：参数使函数变得更灵活！

   返回值：函数调用后，返回的执行结果！――1个数据
   如何返回：声明函数的内部：return 返回值;
	其中：return 退出函数执行并返回结果。
   return仅负责返回数据，不负责保存数据！
   如何保存函数的返回值：调用时：变量=函数名(...);

   ***变量作用域：一个变量可用的范围：2种：
       1. 全局作用域：全局window下的，任何位置都可访问
	    全局变量：保存在全局作用域下的变量
            优势：共享
            劣势：共享的资源，牵一发动全身，易被“污染”
       2. 函数作用域：仅在函数内可用
            局部变量：仅在函数内可用的变量
                2种：1. 声明在函数内的变量
                     2. ***参数变量也是局部变量！
            优势：独有，安全
            劣势：不可重用

    函数作用域及局部变量：随每次函数调用时，临时创建。
                         函数调用完，立刻释放。
                         下次再调用函数，再重新创建。
    函数定义始终存在，不会释放！
        
Day03pm------>
回顾：
***作用域：2种：
 1. 全局作用域：全局变量
 2. 函数作用域：局部变量：2种：在函数内var；参数变量

声明函数：创建了函数的定义，没有执行任何函数体！
调用函数时：创建函数作用域，并在函数作用域中创建局部变量
函数调用后：函数作用域释放！局部变量不复存在！

正课：
1. ***函数：***声明提前  ***按值传递
2. 全局函数――了解
3. *分支结构：

1. 函数：
   ***声明提前：js程序正式执行前，引擎会预读var和function到*当前作用域*的顶部。赋值留在原地
   面试技巧：凡是遇到声明提前的问题，都先预读，再执行。

   ***按值传递：在向函数中传入参数时，
         外部变量仅将值*复制一个副本*，给函数的参数变量
         函数内修改参数变量，不影响函数外原变量的值
         ――最后一句，仅适合原始类型

2. 全局函数：不用加任何前缀(对象)，就可直接调用的函数
     parseInt/Float(str)
     isNaN(x)

     isFinite(x): 是有效范围内的数字
	专门用于判断一个数字是否为Infinity(无穷大) 
     比如：isFinite(n/0);  //false
           isFinite(n/5);  //true
           isFinite(NaN);  //false

   eval(str): 专门执行字符串格式的js表达式，返回执行结果

     %E5%BC%A0 %E4%B8%9C 
       张          东
      utf-8编码
     问题1：url中不允许包含多字节字符
     解决：用专门的函数，将多字节字符，编码成单字节
     如何编码：encodeURI(str)
   对方解码：从单字节，转换回多字节字符：decodeURI(str)
     问题2：url中不允许包含url保留符号,比如: : /等
           http:// ==> 编码为 http%3A%2F%2F
     解决：编码encodeURIComponent(str)
           解码decodeURIComponent(str)
     总结：encodeURIComponent同时包含encodeURI的功能

3. *分支结构：根据不同的条件，选择*执行*不同的*代码段*！
     vs 三目：根据不同的条件，*返回*不同的*值*

    程序结构：3种：
    1. 顺序结构：默认自上向下顺序执行（函数除外）
    2. 分支结构：根据不同的条件，执行不同的任务
    3. 循环结构：程序反复执行同一段代码。

    分支结构：3种：
    1. if结构：1件事，满足条件就做，不满足就不做
       语法：if(条件){
		满足条件才执行的代码
             }
       简写：条件&&满足条件才执行的代码
             仅限于执行的代码只有一句时，才可用

    2. if...else结构：2件事，必须二选一执行
	语法：if(条件){
  		满足条件才执行的代码
              }else{//读作"否则"
          	不满足条件时执行的代码
              }
    3. else if结构：多个条件，多件事，必须多选一执行
	语法：if(条件1){
 		满足条件1 才执行的代码
              }else if(条件2){
     		满足条件2 才执行的代码
              }else if(条件3){
		... ...
              }... ...
              }[else{以上条件都不满足，才执行的代码}]



Day04am------>
回顾：
1. 函数：作用域   声明提前   按值传递
   作用域：全局作用域(全局变量) window
           函数作用域(局部变量:参数变量和函数内的var)
           只要局部有，就不用全局的。
           函数作用域:调用时创建
                      调用完释放
   声明提前：var和function
             仅提前到当前作用域的顶部
  
   按值传递：

正课：
1. *分支结构：switch case
2. *循环结构：

1. switch case: 使用条件表达式的*值*和
                case中的表达式的*值*
                做*全等*(===)比较
      只要碰到全等的值，就进入case下，执行该case的代码段
      默认情况，当前case*之后*的所有代码，一并触发！
   语法：switch(条件表达式){
  	     case 表达式1:
		代码段1;
             case 表达式2:
                代码段2;
             ...
             [default:
		默认代码段;
	     ]
         }

	 
    何时使用：多个条件，多件事，多选一执行
              多用于*等值*比较的条件分支结构

    问题：一个case触发，之后所有case自动都触发
    解决：break; 单独使用：退出当前结构！
    强调：break不是任何情况都要加。
   比如：相邻两case需要连续时，可省略前一个case中的break

2. *循环：程序可反复执行同一代码段
     3种：while    do while   for
    
    循环三要素：
	1. 循环条件：让循环继续执行的条件
	     比如：圈数<3 继续循环  圈数==3 退出循环
        2. 循环变量：循环条件中用作比较的变量
             比如：圈数
          特点：循环变量都会朝着退出循环的趋势不断变化
             如果循环变量满足循环条件的要求，则继续循环
          一旦循环变量不满足循环条件的要求，立刻退出循环
        3. 循环体：循环反复执行的代码段

    while循环：先判断循环条件，再反复执行循环体
	语法：声明并初始化循环变量;
              while(循环条件){
     		循环体;
	        迭代变化循环变量;
              }
死循环：因为循环条件始终满足，导致循环无法退出的特殊循环  
解决：每次循环体之后，向不满足循环条件的趋势，
      迭代变化循环变量


break: 跳出当前结构
退出循环：2种办法：
   1. 使用循环条件控制退出循环――优雅
   2. 使用break; ――野蛮

Day04pm------>
正课：
1. do while循环
2. for循环

1. do while循环：先执行一次循环体，再判断条件，再反复执行
   while vs do while: *第一次*条件不满足：
	while，一次都不执行
        do while,至少执行一次
	              *第一次*条件都满足：两者完全一样！
   语法：do{
   	   循环体;
         }while(循环条件);
   何时使用：即使第一次条件都不满足，也至少能执行一次时

2. for循环：while循环和for循环，本质上完全相同！
   何时使用：循环变量按规律变化时
   语法：
for(声明并初始化循环变量;循环条件;迭代变化循环变量){

                         循环体;
}

   强调：js中没有块作用域。
         在非函数的{}结构中声明的变量，相当于声明在外部
         退出结构后，依然可以使用！

   continue: 跳过本轮循环，继续下一轮循环

      1x1=1
      1x2=2 2x2=4
      ...
第8行 1x8=8 2x8=16 ...         8x8=64

第9行 1x9=9 2x9=18 3x9=27 ...  8x9=72 9x9=81

*
**
***
****
*****

    *
   **
  ***
 ****
*****

    *
   ***
  *****
 *******
*********

提示：找任意一行，空格，星星的个数与行号的规律！




Day05am------>
正课：
1. ***数组
2. *数组API

1. 数组：批量管理多个数据的存储空间――起一个统一的名字
   *程序=数据结构+算法*
   数据结构：程序中数据的存储结构
   算法：程序的执行步骤！顺序，分支，循环

为什么使用数组：现实中，批量管理多个数据都是集中分组存放
          优点：查找方便！
   *良好的数据结构，可极大提高程序的执行效率！*

   如何使用：
　　　1. 创建数组：４种方式：
　　　　　1.var 变量名=[]; -->创建一个空数组
	何时使用：暂时不知道数组中的元素内容时
          2.var 变量名=[值1,值2,...]; 
            -->创建数组同时，初始化数组中的数据
          
          3.var 变量名=new Array(); -->创建一个空数组
          new:在window之外，创建一个新空间，保存多个数据
              返回新空间的地址！
          Array：js中的内置数组类型
	*数组是*引用类型*的*对象*！*
           对象：封装多个数据，并提供对数据的操作方法
                对象=数据+方法
           引用类型：对象不保存在变量本地
                     变量通过对象的地址，使用对象。
                     使用变量等效于使用变量引用的对象
          4.var 变量名=new Array(值1,值2,...);
             -->创建数组同时，初始化数组中的数据
                       new Array(n)
             -->创建n个空元素的数组

      2. 使用数组中每个元素的值：
         数组的存储结构：数组中每个数据都是一个元素
                         每个元素都有唯一的下标
                        数组自动为每个元素生成的序号
                        序号从0开始，递增1
         *最后一个下标=元素个数-1*
         语法：数组变量名[下标]
         每个数组元素的用法和变量完全一样！
         特殊情况：
             1. 输出对象中不存在的元素: undefined
	     2. 给不存在的元素赋值：
		自动在相应位置创建新元素
             强调：无论数组中实际存储几个元素
                   数组的长度只和最后一个下标有关
                   数组长度=最后一个下标+1

    关于地址和内存：
       1. js中只有一种传值方式：按值传递
            原始类型：按值传递后，两变量间无任何关系
            引用类型：传递后，两变量引用同一对象！
                      任何一方修改，都会影响另一方！
       2. 垃圾回收：js引擎中，后台自动运行一个垃圾回收器
              垃圾回收器：专门释放不再使用的对象!
          何时垃圾回收？
		仅当一个对象，不再被任何变量引用时
                垃圾回收器会*自动*释放对象的空间
       3. 主动释放对象：null: 表示一个变量不引用任何对象
                              空地址！
          何时主动释放？
		只要用完一个对象，都要使用null释放。

2. *数组API：API：厂商已定义好的，咱们直接用的方法/函数
                 使用者不必关心实现细节
   数组=数据+功能
   
   数组的元素个数：
	arr.length属性：存储一个数，表示元素个数
      固定搭配：3种
          1. 使用最后一个元素：arr[arr.length-1]
          2. 在数组结尾追加新元素：arr[arr.length]=新值
          3. 删除数组*末尾*的元素：
		改小length的值，数组会自动删除多余元素

   邮件中的问题：其实函数也是引用类型的对象
                 函数名其实是引用函数对象的变量
                 函数对象中存了函数体的定义
    比如: 鄙视题：
          function fun(){ console.log(1); }
          fun(); //?
          function fun(){ console.log(2); }
          fun(); //?
          var fun=100;
          fun(); //?
    
Day05pm------>
正课：
1. *遍历数组
2. *索引数组与关联数组
3. ***冒泡排序（手写）
4. *数组API

1. 遍历数组：
    从头开始，依次取出每个元素的值，*反复*执行相同的操作
    循环三要素：
    1. 循环条件：下标<数组的length属性
    2. 循环变量：下标(i),从0开始，每次增1
    3. 循环体：对每个元素要做的相同操作

    语法：for(var i=0;i<arr.length;i++){
   	     arr[i]：当前i位置的元素
          }

2. 索引数组：自动从0开始，为每个元素顺序编号
    var fbb=["范冰冰", 90 , 65 , 95];
              姓名    数学 语文 英语
    关联数组：可为每个元素自定义*字符串*下标
    如何定义关联数组：2种：
    1. 创建数组，之后，为每个元素单独赋值：
        var fbb=[];
        arr["ename"]="范冰冰";
        arr["shx"]=90;
        arr["yw"]=65;
        arr["yy"]=95;
    何时使用：希望*快速**精确*查找数组中一个元素时
    关联数组(hash数组)
    js中一切都是hash数组！
    js中的数组2不限制：1. 不限制元素个数
                       2. 数组中的元素不限制数据类型
    遍历关联数组：
　　问题1：关联数组下标没规律
    问题2：关联数组的length属性无效
    解决：for in循环
    语法：for(var key in 关联数组){
             key: 当前元素的下标名称
             关联数组[key]: 当前元素的值
          }
3. ***冒泡排序（手写）：从小到大
	从第一个元素开始，依次比较相邻两个元素。
        如果发现大数在前，小数在后，就交换两数位置。
     
     每轮需要从0位置开始，比较(元素个数-轮数)次
     共需要比较（元素个数-1）轮

4. *常用API：
   函数 vs 方法：
      函数：在全局定义的不属于任何对象的function
      方法：包含在对象中，通过对象调用的函数
   1. 将数组转为字符串：2种方法：
      1. arr.toString()：
           输出格式固定：中括号包裹，逗号分隔
      2. arr.join(["分隔符"]):默认等同于toString()
           自定义输出格式中的分隔符号
         固定套路：１.　将字符组成单词：
　　　　　　　　　　　var arr=["H","e","l","l","o"];
                            //Hello
                      var str=arr.join("");
                   2. 将单词组成句子：
                     var arr=["no","zuo","no","die"];
                            //no zuo no die
                     var str=arr.join(" ");
         优化：凡是发现频繁的字符串拼接！
              都要用数组和join方法
    2. 拼接和截取子数组：
       1. 在一个数组的结尾，拼接另一个数组或新元素：
          *原数组不变，返回拼接后新数组对象！*
          var newArr=arr.concat(另一个数组,值1,值2...)
       2. 截取子数组：
          var subArr=arr.slice(starti[,endi+1]);
          //截取arr数组中从starti位置开始，到endi位置结束的元素组成新的子数组返回。
          *含头不含尾*
          特殊：省略第二个参数表示从starti位置截到结尾

       3. splice：删除，插入，替换
          1. 删除元素：arr.splice(开始位置,删除个数);
          2. 插入元素：arr.splice(插入位置,0,新值1,...);
          3. 替换旧元素为新元素:
               arr.splice(开始位置,删除个数,新值1,...);
          *直接修改原数组*
       4. reverse: 翻转所有元素的顺序。arr.reverse();




Day06am------>
补：
创建关联数组：第2种方式：
1. var arr=[];//先创建普通空数组
   arr["key"]=value; //再向数组中添加元素
2. 创建关联数组同时，初始化了数组的内容
   var arr={"key1":value1,"key2":value2,...};
   
鄙视题：
var arr={"a":1,"b":2,"c":3};
var keys=[]; 
var i=0;
for(keys[i++] in arr);
//取出arr中当前元素的key，放入in前的变量中
keys[0]="a"; i=1
keys[1]="b"; i=2
keys[2]="c"; i=3
["a","b","c"]
console.log(keys); //输出：a b c

正课：
1. ***数组：
    ***数组排序：
    *栈和队列操作
2. *二维数组
3. ***String

1. 数组：
   数组排序：
   arr.sort([比较器函数对象]): 直接将原数组按升序排列！
      默认sort方法，将所有元素统一转为字符串，PK unicode
   ***自定义数组排序：2步：
   1. 先定义比较器函数：
    比较器函数：通过返回>0或<0或=0的数
                判断任意两值的大小
    要求：如果a>b，则返回>0的数
          如果a<b, 则返回<0的数
          如果a=b，则返回=0的数
    比如：a-b
          1-12 <0 说明 a<b
          123-23 >0 说明 a>b
          3-3 =0  说明 a=b
    固定套路：function compare(a,b){
  		return a-b;
              }
    函数本质：js中的函数也是一个对象！
              函数名是引用函数对象的变量名！
   2. 将比较器函数作为参数，传入sort方法
    function compare(a,b){
	return a-b;
    }
    //var compare=function(a,b){return a-b;}
    arr.sort(compare);
    何时要加()：只要调用函数时，都要加()
    何时不加：将函数作为对象传递时，仅用函数名即可！
              不加圆括号

    所有排序算法，只有升序排列！
    只要颠倒比较器的正负号(*-1),即可升序改降序。
    
    其实第一步和第二步可写成1句话：
      arr.sort(function(a,b){return a-b;});
    *节省内存空间！*

    function fun(a,b){return a-b;}/*才会被声明提前*/
    vs
    var fun=function(a,b){return a-b;}
    差别：
  
   栈和队列：js中没有专门的栈和队列的类型
             都是用数组模拟出来的！
   栈：一端封闭，只能从另一端进出的数组
       FILO
   何时：只要数组只能从一端进出时
     末尾入栈：arr.push(新值,...)
     末尾出栈：var elem=arr.pop();

     从头入栈：arr.unshift(新值,...)
     从头出栈：var elem=arr.shift();

   队列：只能从末尾进入，从头出的数组
      FIFO
   何时：希望数组中的元素按进入的顺序，依次使用时

Day06pm------>
正课：
1. *二维数组
2. ***String

1. 二维数组：数组中的元素，又引用了另一个数组对象
   何时使用：只要保存横行竖列的数据，
             具有上下级包含关系的数据，
   创建二维数组：
    1. var arr=[];             col
       arr[0]=["保定","唐山","秦皇岛"]; //row
       arr[1]=["郑州","洛阳","驻马店"];
    2. var arr=[
	["保定","唐山","秦皇岛"],
        ["郑州","洛阳","驻马店"] 
       ];

    访问每个元素：arr[行下标][列下标]
    问题：一维数组，下标越界，无论读写都不会出错
          二维数组，列下标越界，无论读写都不会出错
          二维数组，行下标越界，会报错！

    遍历二维数组：外层循环遍历行，内层循环遍历列
        for(var row=0;row<arr.length;row++){
            for(var col=0;col<arr[row].length;col++){
   		arr[row][col]: 获得当前元素
            }
        }

    if(Boolean(x)): 0 "" null undefined NaN -->false
                    其余都是true

2. ***String:字符串类型
     什么是字符串？底层本质一串字符组成的*只读*字符数组

   js内置对象：ES标准中规定的，由厂商已经实现的对象
              程序员只要直接使用即可。不用关心具体实现。
   11个：String  Number  Boolean
   Array Date Math RegExp
   Error（ReferenceError...）
   Function  Object
   Global

   包装类型：临时封装原始类型数据，并提供对数据操作方法的对象――类型名和原始类型名相同！
       String Number Boolean
   何时使用：不必手动创建! 
   js在使用原始类型调用函数时，会自动创建对应的包装类型。
   包装类型生命周期：调用函数时，临时创建
                     函数调用完立刻释放！

String API：
转义字符：当字符串内容和程序的特殊符号冲突时，要用转义字符将特殊符号转为原文！
   比如："js是\"互联网第一大语言\""
         "c:\\windows\\temp.txt"
   另一类转义字符,代替个别键盘功能：
       \t代表1个制表符; \n代表一个换行
day01-->素材-->Homework_string_mario
1. 大小写转换：
   何时使用：凡是希望大小写字母一视同仁时，都要转为相同格式，再比较。
   语法：str.toUpperCase() 将str中的所有小写字母转为大写
         str.toLowerCase()              大写   转  小写

2. 获取指定位置的字符：str.charAt(i) | str[i]
   获取指定位置字符的unicode:var num=str.charCodeAt(i)
   作业：制作编码函数
	请用户输入一句话
         将这句话的每个字符，统一转为5位数字，拼接编码

3. 在字符串中获取关键词的位置：
从左向右查找：var i=str.indexOf("关键词"[,开始位置i])
        省略第二个参数，默认只能从0位置开始！
        *如果找不到了，返回-1*
从右向左找：var i=str.lastIndexOf("关键词"[,开始位置i])
    *虽然查找方向不同，但返回的下标是完全一样的！*
    



Day07am------>
回顾：
1. String API：
   大小写转换
   str.toUpperCase()  str.toLowerCase()
   获取指定位置的字符
   str.charAt(i)  str[i]
   将指定位置字符编码/解码为unicode号
   var num=str.charCodeAt(i); char-->unicode
   var char=String.fromCharCode(num); unicode-->char
   查询：
   从左向右找
   var i=str.indexOf("kword"[,starti]);
   固定套路：查找字符串中所有关键词的位置
   var index=-1;
   while((index=str.indexOf("kword",index+1))!=-1){
       输出本次找到的关键字位置index
   }
   从右向左找
   var i=str.lastIndexOf("kword"[,starti]);
   特殊情况：str第一个字符刚好是关键字的时候
            lastIndexOf第二个参数<0时，
            会始终返回0
   
   固定套路：
   var index=str.length; //13
   while((index=str.indexOf("kword",index-1))!=-1){
       输出本次找到的关键字位置index
       if(index<=0){
	  break;
       }
   }

正课：
1. String API:
2. ***正则表达式

1. String API:
   获取子字符串：3种：
   var subStr=str.slice(starti,endi+1);/*含头不含尾*/
              str.substring(starti[,endi+1]);
   slice: 支持负数参数；substring不支持负数参数;
              str.substr(starti,count);
              substr中starti，可为负。

   分隔字符串：将字符串，按*指定字符*，
               分隔为*多个*子字符串
   var subs=str.split("分隔符"[,几个]);
   何时使用split：今后只要对字符串内容分段处理时，
                  先用split分隔，再遍历每个子字符串！
   固定套路：
   str.split("")――将字符串打散为字符数组

   判断字符串或数组中是否已经包含指定内容
   var i=str.indexOf("关键字")
   var str="no zuo no die";
   var i=str.indexOf("no");
   var arr=["no","zuo","no","die"];
   arr.indexOf("no")――新！

Day07pm------>
正课：
1. String API: replace, match
2. ***正则表达式：

*String所有API都返回新字符串！绝不会直接修改旧字符串*
1. StringAPI：
   替换：var newstr=str.replace("关键词","替换内容");
     默认情况，仅替换第一个找到的关键词
   问题1：仅替换第一个
   解决：模式匹配：i(忽略大小写)   g(Global全局)
   模式语法：/关键词/ig

   查找：var arr=str.match(/关键词/ig);
match方法，仅返回所有关键字的内容，无法返回关键字的位置
     *如果没找到！match方法返回null!*
     *凡是可能返回null，都要先判断null，再执行操作*
何时使用：只需要关键字内容，不需要关键字位置时
search方法，始终仅能查找*第一个*匹配关键字的*位置*
何时使用：只检查有没有

2. ***正则表达式：字符串中字符出现的规则定义
   最简单的正则表达式：关键词的原文  /我草/g
   何时使用：验证――从头到尾完整匹配！
             查找――只要部分匹配即可！
   1.备选字符集：规定某*一位字符*可用的备选字符的集合
      语法：[可选字符列表]
      强调：1. 无论备选字符集包含多少字符，只能选1个
            2. 必须选1个！
      比如：6位数字的密码
[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]
     简化：1. 当备选字符连续时，可用-表示范围的区间
        比如：[0123456789]-->[0-9]
        [0-9][0-9][0-9][0-9][0-9][0-9]
        [a-z]-->1位小写字母
        [A-Z]-->1位大写字母
        [A-Za-z]-->1位字母，大小写都行
        [0-9a-zA-Z]-->1位字母或数字都行
     反选：[^不能选的字符列表]
     比如：[^47] 强调：^作“除了”使用时，只能放在开头

   2. 预定义字符集：为常用的字符集专门提供的简化写法！
        \d-->[0-9]-->1位数字
        \w-->[0-9a-zA-Z_]-->1位字母,数字或_
        \s-->1位空字符：\t  空格
      比如：6位数字：\d\d\d\d\d\d
      
     预定义字符的反义：预定义字符的大写形式都是小写的反义
        \D-->1位非数字字符

     . : 除换行回车外的任何一个字符

   3. 数量词：规定相邻的字符集可出现的次数 
      确定数量：3种：{n}--> 必须反复出现n位
           {n,m}--> 最少出现n次，最多出现m次
           {n,}-->至少出现n次，多了不限！
      比如：\d{6}――6位数字
      手机号规则：
        第1位：只能是1
        第2位：[34578]
        第3位之后，必须是9位数字
      手机号：1[34578]\d{9}

      不确定数量：3种：
        *: 有没有都行，次数不限
        +: 至少1次，重复次数不限
        ?: 有没有都行，最多1次
        ():分组
        |: 左右两正则表达式选其一
      身份证号逻辑：
        前15位数字
        16,17位必须是数字
        最后一位可以是数字或X x
        后三位 可有可无，如果有，只能出现一次
      \d{15}(\d\d[0-9Xx])?

      手机号：
        手机号前可能出现+86或0086。
        前缀可有可无，且只能出现一次
        前缀和手机号之间可以有或没有任意个空字符

	 第1位：只能是1
        第2位：[34578]
        第3位之后，必须是9位数字
      手机号：
      (\+86|0086)?\s*1[34578]\d{9}
    
   4. 指定匹配位置：
      ^表达式: 必须以表达式的规则为开头
      表达式$: 必须以表达式的规则为结尾
     比如：选择字符串开头的空格？^\s*
           选择结尾空格?\s*$
           选择开头或结尾的空格？^\s*|\s*$
     *预告：今后只要在程序中执行验证：都要前加^后加$*
            表示从头到尾完整匹配。
     比如：test()：
       ^\d{6}$――从头到尾必须只能是6位数字
       1234567
   5. 预判：在正式匹配正则表达式之前，先预读整个字符串。
            进行初步匹配。
            如果预判都未通过，则不再验证！
      (?=表达式): 先浏览字符串是否满足表达式的要求
      何时使用：只要正则中出现类似"而且"
      比如：4位数字，但不能包含4和7
      (?=[^47]$) 是否由除了4,7之外的字符组成
            \d{4}要求只能是数字组成
      (?!表达式):先检查字符串是否*不满足*表达式要求
　　　比如：6位以上密码。
	   字母,数字组成
           首字母不能是数字: [a-zA-Z][a-zA-Z0-9]{5,}
           必须至少包含1个大写字母
           不能都由小写字母和数字组成: (?![a-z0-9]+$)
           必须至少包含1个数字
           不能都由小写字母和大写字母组成:
           	(?![a-zA-Z]+$)

var str="eric ,   rose, scott  , john";
var names=str.split(/\s*,\s*/);
console.log(names);

   贪婪模式和懒惰模式：
   贪婪模式：默认情况下，正则表达式会匹配最大的符合条件的字符串
   贪婪模式原因：(.*) (.+)
   懒惰模式：正则表达式仅匹配最小的符合规则的字符串
   比如：筛选网页中的a元素：
      <a\s+(.*)href\s*=\s*["']([^'"]*)["']
   贪婪模式-->懒惰模式：.*?

   中文范围：[\u4e00-\u9fa5]



Day08am------>
正课：
1. *RegExp
2. *Math
3. *Date

1. RegExp对象: 封装一个正则表达式，提供了利用正则表达式执行验证和查找的功能
   何时使用：只要利用正则表达式验证，查找时
   如何创建：
	一旦程序运行，正则表达式不会改变时：
            /正则表达式/ig
        一旦程序运行，有可能动态更换正则表达式时
            new RegExp("正则表达式","ig"); 
   强调：第二个的注意事项：
     1. 所有\都要变为\\
        new RegExp("^\\s+|\\s+$","ig");
     2. 正则表达式中包含"或'
	"<a\\s+(.*?)href\\s*=\\s*[\'\"][^\'\"]*[\'\"]"

RegExp API:
   1. 查找：回顾：String中：
           search(有没有) match(所有关键内容和个数)

      reg.exec(str)即可找到每个关键字内容，又可找位置 
      每次仅查找一个找到的关键字：3件事:
      1. 将关键字内容存入一个数组中返回
      2. 将关键字的位置下标存入数组的index属性中
      3. 自动将下次开始位置，变为当前关键字的下一个下标
      *如果没找到，返回null！ *  
 
      如何获得*本次*,查找结果的*部分内容*：2步：
     1. 确认要获取的部分子表达式，被圆括号包裹！
     2. RegExp.$n ： 
            表示本次查找结果中，第n个括号中匹配的部分

     查找总结：
     1. str.indexOf/lastIndexOf: 不支持正则！
          循环可获得所有关键字的位置！不能获得内容
          每次循环都要修改第二个参数为下一个位置
          找不到，返回-1
     正则：
     2. str.search:判断有没有，只能获得第一个匹配的内容
          没有第二个参数！
          找不到，返回-1
     3. str.match:获得所有关键字的内容，无法获得位置
          找不到，返回null
     4. reg.exec(str): 既可获得内容，又可获得位置
         必须循环反复调用，每次循环不必手动维护lastIndex
          找不到，返回null

   2.验证：要求被验证的字符串和正则表达式从头到尾完成匹配
         只要验证：前加^,后加$
     reg.test(str): 如果匹配，返回true，否则返回false！

字符串中支持正则的API：
   var i=str.search(/正则/); 
   var arr=str.match(/正则/g);
   var arr=str.split(/正则/);

   var newStr=str.replace(/正则/g,"替换内容");
   特殊情况：2种：
   1. $n：replace中$n同RegExp.$n，当不能带RegExp。
          直接写在新值字符串内
   2. 去空格：3个函数：
      ltrim:去字符串开头空格,
      rtrim:去字符串结尾空格,
      trim:去字符串前后的空格
    
2. Math对象：封装数学计算中常用的常量值,提供了常用的数学   *不能被实例化*
   取整：3种：Math.round(n) Math.ceil(n) Math.floor(n)
              四舍五入        上取整       下取整
      var str=num.toFixed(n)
              按n位小数四舍五入
      问题：Math.round虽返回num类型，但只能取整
           toFixed虽可以按任意小数取整，但返回字符串类型
      解决：自定义一个函数，即可按指定位数四舍五入
                           又返回number类型数值

   随机数：Math.random();
   任意范围取随机：
     Math.floor(Math.random()*(max-min+1)+min)


Day08pm------>
正课：
1. *Math
2. *Date

1. Math：不能new
   取整：3种
   Math.round(num)  Math.ceil(num) Math.floor(num)
   四舍五入*取整*    上取整          下取整
   
   四舍五入：var str=n.toFixed(2);
   解决：实现一个round函数,要求可以对任意位数四舍五入

   乘方/开方:
   Math.pow(n,m): 计算n的m次方
   Math.sqrt(n): 计算n的*平方*根

   获取最大值/最小值
   Math.max(x1,x2,x3....)
   Math.min(x1,x2,x3....)
   固定套路：获取数组中的最大值/最小值
   *Math.max.apply(Math,arr);*
   apply: 在调用时，临时更换调用方法的对象
          并将参数以数组形式传入
   obj1.fun.apply(obj2,[p1,p2,p3....]);
   Math.max.apply(Math,[p1,p2,p3....]);
   等效于
   obj2.fun(p1,p2,p3....)
   Math.max(p1,p2,p3....)

   随机数：
   Math.floor(Math.random()*(max-min+1)+min)

2. Date: 封装1个时间点，提供对时间的计算功能
   Unix: 1969年 1970年1月1日 0:00:00
   Date对象中封装了当前时间点到1970年元旦的毫秒数
   
   创建：4种：
   1. var now=new Date(); now获得当前客户端时间
   如何自定义时间：
   2. 自定义时间：
	var date=new Date("xxxx/xx/xx[ xx:xx]");
   3. 复制一个实现对象：
        var date=new Date(毫秒数);
   4. 以分量方式自定义时间
        var date=new Date(年,月-1,日[,时,分,秒]);
      强调：月份从0开始，到11结束
            计算机中的月份比现实中的月份数小1

   Date API：
    JavaScript-->左侧js对象-->js日期-->中间找：
         JavaScript Date对象参考手册
    3句话：
    1. 每个分量都有一对get/set方法：8对儿，少1个(setDay)
      比如：getFullYear()  
            setFullYear(year)

            getMonth()
            setMonth(month);
   
            getDay() 获得星期，从0开始到6结束
                     因为星期日为0，所以其他星期不用修正
            没有setDay()
    2. 命名：年月日星期不带s结尾
             时分秒毫秒以s结尾
            getHours() 从0-23
            setHours(hours)
            
            getMinutes() 从0-59
            setMinutes(minute)
    3. 取值：只有月中的日从1开始到31结束
             其余都是从0开始，到进制-1结束

    强调：所有set方法，会自动调整进制！

    时间计算：2种：
      1. 两日期对象相减：得到毫秒差-->/进制-->天/小时...
      2. 单个时间点做加减：3步：
        1. 取分量   2. 做加减   3.set回去
        强调：set方法都直接修改原日期对象！

    时间显示：默认显示不好用
      date.toString()-->默认以标准时间显示日期
      date.toLocaleString()
	-->将日期转为操作系统当地时间格式
      date.toLocaleDateString()
        -->仅获取Date对象中的日期部分
      date.toLocaleTimeString()
        -->仅获取Date对象中的时间部分
    自定义时间格式化函数：format
      



Day09am------>
正课：
1. *错误处理
2. ***Function对象

1. 错误处理：
      错误：程序运行过程中发生的异常状态
            导致程序停止运行――异常
      错误处理：当程序发生错误时，保证程序不退出的机制

      发生错误时，程序会自动创建一个Error对象：
      Error对象中仅封装了错误的信息
      js种 *6种* 错误对象：
      SyntaxError: 语法错误
      ReferenceError: 引用错误
      TypeError: 类型错误，错误的使用了类型或类型的方法
      RangeError: 范围错误，特指函数的参数范围！
      EvalError: 调用eval函数时发生的调用错误
      URLError: URL错误

      如何错误处理：
      语法：try{
            	正常执行流程;(有可能发生错误)
            }catch(err){
          	当错误发生时，才执行的代码
                2种操作：1. 记录/显示错误信息
                         2. 继续向调用者抛出新错误
            }[finally{
       		无论对错，必须始终执行的代码――善后
                一般finally中，释放占用的资源
            }]
      何时使用：今后只要程序有可能抛出错误
                就要将可能发生错误的代码放入try中
          一般三种情况：1. 用户输入的数据
                        2. 使用个别浏览器不兼容的对象
                        3. 向服务器发送/接收消息时
                        4. null/undefined

      鄙视题：见1_error.html：
      错误处理中的return
        1. finally中没有return，其他位置的return会先确定要返回的值，暂时挂起，再执行finally中的代码
         finally中的操作不影响其他位置已经确定的return值
        2. finally中有return，会替换其他位置的return

      抛出自定义错误！
      何时需要抛出自定义错误：
          自己实现的函数，被被人调用时。为了向合作伙伴提示开发错误，都要主动抛出错误信息。
      语法：throw new Error("自定义错误信息")
	强调：throw new Error后的代码不再执行！

     try catch vs if else
       如果有机会说过if else进行过滤，优先选择if else
       没有机会做if判断时，只能选择try catch
     try catch更占用资源

11个内置对象：
String Number Boolean
Array Date Math RegExp
Error(6个)
Function Object
Global（window）

2. ***Function对象：
    *js中一切都是对象！*
    *连函数都是对象！*
    普通对象 vs 函数对象：
      普通对象：封装数据，并提过对数据的操作
      函数对象：不封装数据，反而是一个可调用的对象

   ***重载：多个函数，拥有相同的函数名，但不同的参数列表
   调用时，可根据传入的参数值列表，自动调用匹配的函数
   何时使用重载：今后只要一件事！可能根据参数的不同，执行不同的流程时，就要用重载！不要为每种流程分别起名。
   真正的重载：tmooc/java/java面向对象/类中的方法

   *js中不支持重载的语法！*
   *js中可使用arguments对象，模拟重载的效果！*
   
   arguments对象：所有function内部，自动创建的一个对象
                 专门顺序接收所有传入函数的参数
                 可当做数组使用！
   类数组对象：长得像数组的*对象*
 无论函数有没有定义参数变量，arguments都能获得所有参数值


Day09pm------>
正课：
1. ***Function对象
   如何创建一个函数对象：3种方法：
    1. 声明方式：function 函数名(参数列表){函数体}
       只有声明方式的函数定义才会被提前
       写在调用前后都行
    2. 直接量方式：var 函数名=function(参数列表){函数体}
       只能写在调用之前！
    3. 使用new创建函数对象：
       var 函数名=new Function("a","b",...,"函数体");
       在运行时动态修改函数体。
       效率较低
   比如：一下js创建函数正确的是：
     function compare(a,b){return a-b;}
     var compare=function(a,b){return a-b;}
     var compare=new Function("a","b","return a-b");

   ***内存中的函数对象：***
   1. 声明函数时，创建了2个对象：
	函数对象：保存函数的定义本身
        作用域链对象：顺序保存了函数可用的变量范围的地址
        默认情况，作用域链对象中只有一个元素，指向window
   2. 调用函数时：2件事：
       1. 在作用域链对象中追加一个新元素
            新元素指向将要创建的函数活动对象
       2. 创建本次调用函数的活动对象：
           活动对象：调用时临时创建的，
                     仅保存函数*局部变量*的对象
       调用时，使用变量的优先级遵循先局部，后全局的顺序
       如果活动对象中有，就不用全局的。
   3. 调用后：1件事：作用域链中指向活动对象的引用，出栈
       活动对象的引用出栈，活动对象变为垃圾，被回收。
       局部变量不复存在。

   匿名函数：声明时，不指定函数名的函数。
   何时使用：2种情况：
     1. 一个函数只会被调用一次！――自调
     2. 函数不是自己调用，传递给别人用――回调
   用途：回调和自调
     回调：函数定义后，传递给其他调用者使用。
	   定义者不需要关心何时调用和调用次数。
     比如：比较器函数
        //以直接量方式创建函数：不是匿名函数
        //var compare=function(a,b){return a-b;}

        arr.sort(function(a,b){return a-b;});
                       匿名函数
     匿名函数的优点：节约内存空间：
               匿名函数只在调用时三大对象
               调用后三大对象都自动释放

     自调：匿名函数创建同时，立刻调用自己！

    ***闭包：在函数外也可使用局部变量的特殊语法现象
    全局变量 vs 局部变量：
       全局变量：优：可共享，可重用;  
                 缺：在任意位置都可随意修改――污染
       局部变量：优：安全
                 缺：不可共享，不可重用
    何时使用闭包：即共享局部变量，又不希望随便篡改时。
    就要构建一个闭包结构：3步：
    1. 使用外层函数封装受保护的局部变量
    2. 在外层函数内定义专门操作局部变量的内层函数
       *并返回*。
    3. 在全局调用外层函数，获得内层函数的对象，保存在全局变量中反复使用。  

    闭包三特点：
    1. 嵌套函数
    2. 内层函数使用了外层函数的局部变量
    3. 内层函数对象被返回到外部，在全局反复调用 

    闭包的作用：保护可共享的局部变量
　　*如何快速判断闭包函数的输出结果：*
　　１.外层函数调用了几次，就有几个受保护的局部变量

   鄙视题：
   function f1(){
      var n=999;
      nAdd=function(){n+=1}
      function f2(){alert(n);}
      return f2;
   }   
   var result=f1();//n=999
   result(); //999
   nAdd(); //n=1000
   result(); //n=1000
　　



Day10am------>
正课：
1. ***OOP:面向对象程序设计
	对象：程序中描述现实中一个物体的属性和功能的结构
             一个对象专门代表现实中的一个物体
              封装事物的属性和功能的结构
        比如：你的手机：
           属性：屏幕大小：5.5
                 处理器: A8
                 运行内存：2G
                 存储：64G
                 通讯录：["李大嘴":12312312345,
                          "郭芙蓉":32132154321,
                          "吕秀才":23423423456]
           功能：打电话(电话号码){}
                 发短信(电话号码,msg){}

    1. 如何创建：3种
      1. 使用直接量创建1个对象：
          var obj={属性名:属性值,
                   属性名:属性值,
                   方法名:function(){...}
                   };
         js底层，所有对象都是用hash数组存储的！
      强调：对象自己的方法要使用自己的属性，
            必须用this.属性名
        this.读作“当前对象的”

        何时使用：仅创建一个单独的对象时
      2. 使用构造函数创建多个统一结构的对象
        优：只需一次定义结构，即可反复创建相同结构的对象
        如何使用构造函数:2步：
        Step1: 定义构造函数
        function 类型名(属性参数1,属性参数2,...){
        	this.属性名1=参数1;
                this.属性名2=参数2;
                this.方法名=function(){...}
        }
          Step2: 调用构造函数函数创建对象！
        var obj=new 构造函数名(属性值1,属性值2,...);
        强调：this指正在创建的对象
        其实程序执行了4步：
         1. new 创建空对象空间
         2. 调用构造函数，在对象中添加规定好的属性和功能
         3. ？
         4. 将新对象地址，返回调用者

     3. 先创建空对象，再设置属性
        var obj=new Object(); //创建空对象
               ={};
        obj.属性1=值1;
        obj.属性2=值2;
        obj.方法=function(){...}
        何时使用：创建对象时，暂时不知道对象中的结构
                 可先创建空对象，之后逐渐追加属性和方法
        
     固定套路：遍历对象中所有属性和方法: for in结构
     
   *判断对象中是否存在指定属性：2种*\
	如果存在，则返回true；否则返回false
   1. "属性名" in obj： 
      如果obj是原始类型变量，可new空包装类型对象，再检测
   2. if(obj.方法名===undefined)： 属性名不存在
      专门验证方法名是否存在――使用最频繁的！
      可简写为if(obj.方法名)

   ***this：只用于对象中的方法，访问对象自己的属性
          this指代正在调用方法的当前对象！
   *this和定义在哪儿无关！只和调用时的对象有关！*

        

    2. ***原型/原型链：
    3. ***继承




Day10pm------>
正课：
1. ***原型/原型链：
2. ***继承

*面向对象3大特点：封装，继承，多态*

1. 原型：集中保存所有对象公用属性*值*和方法的对象。
     每个函数都有一个属性prototype,指向自己的原型对象
     重点作用于构造函数！
     每个对象都有一个__proto__属性，执行创造自己的构造函数的原型！
   什么样的属性才会放入原型？所有对象共享的属性*值*
   什么样的方法才会放入原型？希望所有对象共有的方法

   new 构造函数(); 4步：
   1. new创建空对象
   2. 调用构造函数向新对象中添加属性和方法
   3. 设置新对象的__proto__属性指向构造函数的原型对象
   4. 返回新对象的地址给调用者

   删除属性：delete 对象.属性：删除自有属性
       delete 构造函数.prototype.属性：删除共有属性

   自有属性：直接通过对象.或构造函数创建的属性
            自有属性仅属于当前对象所有
   共有属性：通过构造函数的*原型*添加的属性
            共有属性，所有对象共享其值。

   *如何判断自有属性和共有属性：2种：*
   1. 仅检查自有属性：obj.hasOwnProperty("属性名");
       如果hasOwnProperty返回false，
   2. 检查原型链上的对象中，是否包含指定属性：
      （检查共有属性）
      语法："属性名" in 对象

原型链：由每个对象的__proto__属性连续引用形成的多级关系

   继承：父对象中的属性值或方法，子对象可直接使用。
   *js中通过修改子对象的原型为一个父对象来实现继承*
   如何设置子对象继承父对象：3种方式：
   1. 单独修改一个对象的父对象，不影响其他对象
      Object.setPrototypeOf(子对象,父对象)
   2. 直接修改构造函数的原型对象。
      不影响已创建的对象
      会影响之后新创建的对象
      语法：构造函数.prototype=父对象
   3. 创建新对象同时，手动设置父对象：
      语法：var newObj=Object.create(父对象)
      只影响正在创建的对象。

   重写：*子对象觉得父对象的方法不好用*
         自己定义同名的，但不同实现的方法

   ***扩展内置对象的公共方法***
   比如: function indexOf(arr,elem)
         var arr=[];
         //var i=indexOf(arr,4);
	 var i=arr.indexOf(4)
   再比如：var str="no zuo no die";
           var i=new String(str).indexOf("no");
   1.在内置对象类型的原型中，添加扩展方法！
   2.在方法内使用this，获得正在调用函数的对象

   作业：
   1. 扩展Date类型的format方法
      测试代码：
      console.log(new Date().format);
   2. 扩展Number类型的round方法
      测试代码：
      var n=123.456;
      console.log(n.round(2)); //123.46
      console.log(typeof(n.round(2))); //number
    



Day11am------>
回顾：
1. 创建对象：4种方式：
   1. 创建单个对象：直接量:
      var obj={属性1:值1,...,方法1:function(){},...};
   	obj.__proto__指向Object.prototype
   2. 使用构造函数，反复创建多个相同结构的对象：2步：          1. 定义构造函数：
	参数接收特定对象的属性值
        this.属性名=参数值,为当前对象添加属性，并初始化
        function 构造函数名(参数1,参数2,...){
     	    this.属性1=参数1;
            ...
            //this.方法=function(){};
	    if(!构造函数.prototype.方法){
               构造函数.prototype.方法=function(){...};
            }
        }
        
      2. 使用new关键字调用构造函数:
	var obj=new 构造函数名(属性值1,属性值2,...);
        4件事：
        1. 创建新对象
        2. 调用构造函数，为新对象添加属性和方法，并赋值
        3. 将新对象的__proto__属性指向构造函数的原型对象
        4. 返回新对象的地址给调用者
    3.new Object(): 只在暂时不知道对象属性和方法时
   (4.var obj=Object.create(父对象)
     创建一个新对象同时，设置新对象的__proto__指向父对象
 
2. this：指代正在调用方法的当前对象
     *和定义位置无关！仅和*调用*时使用的对象有关*
   比如：为Number类型的所有对象添加round方法
     
3. 面向对象三大特点：封装，继承，多态
   封装：将现实中一个事物的属性和功能，集中定义在程序中的一个对象里。
   继承：父对象的属性和方法，子对象不用重复定义，可直接用
       目的：代码重用！   
   多态：一个对象在不同的情况下，显示不同的状态
       js中对多态支持不好。仅讨论重写。
       重写：子对象觉得父对象的共有方法不好用
             自己可定义同名的自有方法。

4. 原型/原型链：
   原型：每个函数对象都有一个prototype属性
         指向自己的原型对象
       构造函数的原型对象中的属性和方法，所以子对象可继承
 每个对象都有一个__proto__属性引用自己构造函数的原型对象
   什么属性或方法该放入原型：
	共享属性*值*的属性；
        共享的方法：使用this获得正在调用方法的子对象
         
   原型链：由每个对象的__proto__构成的多级继承关系
     所有对象的原型链顶部都继承自Object.prototype
     所有函数对象的原型链一定都继承自Function.prototype
Function.prototype的__proto__属性指向Object.prototype
     Object.prototype.__proto__=null!

5. 检测某个对象是否拥有指定的属性或方法：3种：
    检测原型链中是否包含：2种：
    1. "属性名" in 对象
    2. 判断存在
	if(对象.属性名!==undefined)-->*if(对象.属性名)*
       判断不存在
        if(对象.属性名===undefined)-->*if(!对象.属性名)*
    仅检测自有属性：1种：
	Object.hasOwnProperty(对象,"属性名")
6. 扩展内置对象的内置方法：
    之前先检查是否已经包含：
    if(!("方法名" in 构造函数.prototype))
    1.将新方法添加到内置对象构造函数的原型中
      比如: Array.prototype.indexOf=function(elem){...}
    2.新方法内使用this指代未来调用该方法的实际对象
        Array.prototype.indexOf=function(elem){
	    for(var i=0;i<this.length;i++){
		...
        }
        调用时,arr.indexOf("4")-->this->arr

7. 继承：2种
   1. 原型继承：通过修改对象的__proto__属性，
                直接继承一个对象！
      2种：
      1. 单独修改一个对象的__proto__属性
       Object.setPrototypeOf(子对象,父对象);
       仅影响一个对象，不影响同类型其他对象
      2. 统一修改见后所有子对象的公共原型对象
       构造函数.prototype=父对象
       不影响修改前已创建的子对象
       仅影响修改后创建的新子对象
***特殊：如果不希望修改内置构造函数的原始原型对象
       为构造函数指定一个新的自定义的原型对象
       function MyArray(){}
       //(1)MyArray.prototype=Array.prototype;
       (2)MyArray.prototype=[];//new Array();
       
       MyArray.prototype.indexOf=function();
       (1)今后所有数组对象的indexOf方法都会被篡改
       (2)仅影响由MyArray创建出的子对象
          普通数组对象不受影响
       (2)是推荐的。

       var mA=new MyArray();
       mA.push(100); //100存放的位置：mA对象本地
       push方法中可能有类似：this[this.length]=100;
       调用时,this-->mA -->100实际存入mA对象中

    2. 继承结构：最像Java的继承
        子类型的构造函数中，又调用了父类型的构造函数
       function Flyer(fname,speed){
	   this.fname=fname;
           this.speed=speed;
	   if(!Flyer.prototype.fly){
  	   Flyer.prototype.fly=function(){
console.log(this.fname+"以时速:"+this.speed+" 飞行");
           	}
           }
       }
       function Plane(fname,speed,capacity){
	   Flyer(fname,speed);
           this.capacity=capacity;
           if(!Plane.prototype.fly){
      	   Plane.prototype.fly=function(){
console.log(this.fname+"搭乘"+this.capacity+"乘客 以时速:"+this.speed+" 飞行");
           	}
           }
       }

    call和apply: 在调用时，临时更换调用方法的对象！
       要调用的方法.apply(替换对象,[参数值列表])
       要调用的方法.call(替换对象,参数值1,...)

8. 检查两对象之间的继承关系：
	父对象.isPrototypeOf(子对象)
      强调：不但可检测直接父对象，
            还可检测整个原型链上的所有父对象
       
鄙视题：如何判断一个对象是数组：5种办法
    1. typeof(对象)-->类型名 -->无效！
    2. 利用原型：2种
	Array.prototype.isPrototypeOf(arr) //true
        子对象 instanceof 父构造函数 //true
        instance: 实例：凡是用new 构造函数()创建出的对象，都称为是构造函数的实例
    3. 利用构造函数constructor
        arr.constructor==Array //true
    4. 利用toString方法
Object.prototype.toString.call(arr)==="[object Array]"
    5. Array.isArray(arr)：ES5中新
  
    总结：4+5
    function isArray(obj){
        if(Array.isArray){
           return Array.isArray(obj);
        }else{
return Object.prototype.toString.call(obj)==="[object Array]"
        }
    }
    
 
